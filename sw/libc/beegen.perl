use strict;





sub genfile($$$) {
    my $name = shift;
    my $cmmt = shift;
    my $text = shift;

    open(F,">",$name.".s");

    print F
'    .include  "stdas.as"
// ------------------------------------------------------------
// THIS FILE AUTOMATICALLY GENERATED BY beegen.perl
// DO NOT EDIT
//
';

    foreach my $ln (@$cmmt) {
	print F '// ',$ln,"\n";
    }

    print F
'// ------------------------------------------------------------
    .code

';

    print F "    .globl       _",$name,"\n";
    print F "_",$name,":\n";
    print F "\n";

    foreach my $ln (@$text) {
	print F $ln,"\n";
    }

    close(F);
}





sub genCfile($$$) {
    my $name = shift;
    my $cmmt = shift;
    my $text = shift;

    open(F,">",$name.".c");

    print F
'#include <bee.h>
// ------------------------------------------------------------
// THIS FILE AUTOMATICALLY GENERATED BY beegen.perl
// DO NOT EDIT
//
';

    foreach my $ln (@$cmmt) {
	print F '// ',$ln,"\n";
    }

    print F
'// ------------------------------------------------------------


';

    foreach my $ln (@$text) {
	print F $ln,"\n";
    }

    close(F);
}










sub dcachecmd($$$) {
    my $inval = shift;
    my $count = shift;
    my $first = shift;

    my $i = 0x80000003;
    $i |= $inval << 17;
    $i |= $count << 10;
    $i |= $first << 3;

    return sprintf("0x%08x",$i);
}





sub dcacheoptitle($) {
    my $op = shift;
    if ($op eq "flush") { return "Flush"; }
    if ($op eq "inval") { return "Invalidate"; }
    if ($op eq "empty") { return "Flush & invalidate"; }
    die "illegal op $op";
}






foreach my $op ("flush", "empty") {



    genfile("bee_dcache_".$op."_all",
	    [
	     dcacheoptitle($op)." entire data cache",
	     ],
	    [
	     "    ld           t1,link      // return address",
	     "",
	     (($op eq "flush") ?
	      (
	       "    aqw_long_ld  vb,".dcachecmd(0,127,0)." ROL 2",
	       ) :
	      ($op eq "inval") ?
	      (
	       "    aqw_long_ld  vb,".dcachecmd(1,127,0)." ROL 2",
	       ) :
	      ($op eq "empty") ?
	      (
	       "    aqw_long_ld  vb,".dcachecmd(0,127,0)." ROL 2",
	       "    aqw_long_ld  vb,".dcachecmd(1,127,0)." ROL 2",
	       ) :
	      (die "illegal op $op")),
	     "",
	     "    j            t1",
	     ]);
    



    genCfile("bee_dcache_".$op."_rgn",
	    [
	     dcacheoptitle($op)." region",
	     ],
	    [
	     "void bee_dcache_".$op."_rgn (void * a,size_t n)",
	     "{",
	     "  if (n == 0) return;",
	     "",
	     "  unsigned int start = (unsigned int)a;",
	     "  unsigned int after = start + n;",
	     "",
	     "  unsigned int firstline = start >> 7;",
	     "  unsigned int lastline = (after - 1) >> 7;",
	     "",
	     "  unsigned int countlessone = lastline - firstline;",
	     "",
	     "  if (countlessone >= 127) {",
	     "    /*",
	     "     * This command will affect the entire cache,",
	     "     * so just perform the whole cache version.",
	     "     */",
	     "",
	     "    bee_dcache_".$op."_all();",
	     "    return;",
	     "  }",
	     "",
	     "  unsigned int firstalias = firstline & 127;",
	     "",
	     "  /*",
	     "   * According to Chuck, a dcache command in which",
	     "   * first + count wraps around the cache is illegal.",
	     "   * So for such a case, we have to break it up into",
	     "   * two dcache commands.",
	     "   */",
	     "",
	     "  if (firstalias + countlessone > 127) {",
	     "    /*",
	     "     * At this point we must have ( firstalias > 0 )",
	     "     * because we know that ( countlessone < 127 )",
	     "     */",
	     "",
	     "    unsigned int countlessonexx = 127 - firstalias;",
	     "    bee_dcache_".$op."_cachelines(firstalias,countlessonexx);",
	     "",    
	     "    /*",
	     "     * Note that ( countlessone > 127 - firstalias )",
	     "     * therefore ( countlessone > countlessonexx )",
	     "     */",
	     "",
	     "    firstalias = 0;",
	     "    countlessone -= countlessonexx + 1;",
	     "  }",
	     "",
	     "  bee_dcache_".$op."_cachelines(firstalias,countlessone);",
	     "}",
	     ]);

}




    
genfile("bee_dcache_command_internal",
	[
	 "Perform dcache command",
	 "",
	     "Input:",
	     "    r3 = command word",
	     ],
	    [
	     "    aqw_ld       vb,r3",
	     "    j            link",
	     ]);







foreach my $op ("i", "n", "eth", "clock") {


    genfile("bee_core_".$op,
	    [
	     ($op eq "i") ? ("Get my core number") :
	     ($op eq "n") ? ("Get highest numbered normal core") :
	     ($op eq "eth") ? ("Get ethernet core number") :
	     ($op eq "clock") ? ("Get clock speed in MHz") :
	     (die "illegal op $op"),
	     "",
	     "Output:",
	     "    r1 = core number"
	     ],
	    [
	     "    aqr_ld     vb,0x80000000 ROL 2  // read asli register",
	     ($op eq "i") ?
	     (
	      "    lsr        r1,rq,10         // right align core number",
	      "    and        r1,r1,15         // mask to core number",
	      ) :
	     ($op eq "n") ?
	     (
	      "    lsr        r1,rq,14         // right align eth core",
	      "    and        r1,r1,15         // mask to core number",
	      "    sub        r1,r1,1          // less 1",
	      ) :
	     ($op eq "eth") ?
	     (
	      "    lsr        r1,rq,14         // right align eth core",
	      "    and        r1,r1,15         // mask to core number",
	      ) :
	     ($op eq "clock") ?
	     (
	      "    lsr        r1,rq,18         // right align clock speed",
	      "    and        r1,r1,127        // mask",
	      ) :
	     (die "illegal op $op"),
	     "    j          link",
	     ]);
}







genfile("bee_msg_send_w",
	[
	 "Send an inter-core message",
	 "",
	 "Input:",
	 "    r3 = destination core number",
	 "    r4 = message type (0..15)",
	 "    r5 = word address of message payload",
	 "    r6 = number of words in payload (0..63)",
	 ],
	[
	 "    ld         t1,link    // return address",
	 "",
	 "    sub        r5,r5,4    // predecrement payload address",
	 "    ld         r2,r6      // payload word count",
	 "    jz         L2",
	 "L1:",
	 "    aqr_add    r5,r5,4    // fetch next payload word",
         "    ld         wq,rq      // stuff onto wq",
         "    sub        r2,r2,1    // decrement word count",
	 "    jnz        L1",
	 "L2:",
	 "",
         "    ror        r1,0x80000004 ROL 2,3+2",
	 "    or_ror     r1,r1,r3,4",
	 "    or_ror     r1,r1,r6,6",
	 "    or_rol     r1,r1,r4,13+2",
	 "    aqw_ld     vb,r1      // send message",
	 "",
	 "    j          t1",
	 ]);




genfile("bee_msg_poll_w",
	[
	 "Poll to receive an inter-core message",
	 "",
	 "Input:",
	 "    r3 = word address to store message payload",
	 "",
	 "Output:",
	 "    r1 = status word",
	 ],
	[
	 "    ld         t1,link    // return address",
	 "",
	 "    aqr_ld     vb,0x80000004 ROL 2",
	 "    ld         r1,rq",
	 "    jz         t1         // no message...",
	 "",
         "    sub        r3,r3,4    // predecrement payload address",
	 "    and        r2,r1,63   // payload word count",
	 "    jz         L2",
	 "L1:",
	 "    aqw_add    r3,r3,4    // store next payload word",
         "    ld         wq,rq      // pull from rq",
         "    sub        r2,r2,1    // decrement word count",
	 "    jnz        L1",
	 "L2:",
	 "",
         "    j          t1",
	 ]);









foreach my $op ("cacq", "rel") {


    genfile("bee_lock_".$op,
	    [
	     ($op eq "cacq") ? ("Conditionally acquire lock") :
	     ($op eq "rel") ? ("Release lock") :
	     (die "illegal op $op"),
	     "",
	     "Input:",
	     "    r3 = lock number (0..63)",
	     ($op eq "cacq") ?
	     ("",
	      "Output:",
	      "    r1 = non-zero on success",
	      ) :
	     ($op eq "rel") ? () :
	     (die "illegal op $op"),
	     ],
	    [
	     "    ld         r1,0x80000005 ROL 2",
	     "    and_rol    r3,r3,63,3+2",
	     ($op eq "cacq") ?
	     (
	      "    aqr_or     vb,r1,r3          // attempt to acquire",
	      "    ld         r1,rq             // get result",
	      ) :
	     ($op eq "rel") ?
	     (
	      "    aqw_or     vb,r1,r3          // release",
	      ) :
	     (die "illegal op $op"),
	     "    j          link",
	     ]);
}



